%YAML 1.2

---

name: Evi
file_extensions: [evi, evii]
fileTypes: [evi]
scope: source.evi

variables:
  ident: "[A-Za-z_][A-Za-z_0-9]*"

  # numbers
  decimal: '\b[0-9]+(\.[0-9]*)?\b'
  binary: '\b0b[0-1]+\b'
  octal: '\b0c[0-7]+\b'
  hexadecimal: '\b0x[0-9a-fA-F]+\b'
  number: '{{decimal}}|{{binary}}|{{octal}}|{{hexadecimal}}'

  # types
  inttype: '(?:u)?i(?:(?:128)|(?:16|32|64)|(?:4|8))|i1'
  type: '({{inttype}}|flt|dbl|bln|nll|chr)(\*)*'

contexts:
  # The prototype context is prepended to all contexts but those setting
  prototype:
    - include: comments
    - include: pre-directive

  main:
    # The main context is the initial starting point of our syntax.
    # Include other contexts from here (or specify them directly).
    - include: comment
    - include: pre-directive
    - include: declaration
    - include: statement

  type:
    - match: \b{{type}}\b
      scope: storage.type.evi

  number:
    - match: \b{{number}}\b
      scope: constant.numeric.evi

  string-char:
    - match: '\"'
      push:
        - meta_scope: string.quoted.double
        - match: '\"'
          pop: true
        - include: escaped-char
        - include: format-specifier

    - match: "'"
      push:
        - meta_scope: string.quoted.single
        - match: "'"
          pop: true
        - include: escaped-char

  operator:
    - match: <<|>>|>>
      scope: keyword.operator.bitwise.shift.evi
    - match: ==|/=
      scope: keyword.operator.comparison.evi
    - match: <=|>=|<>|<|>
      scope: keyword.operator.relational.evi
    - match: \!|&&|\|\||\?\?|:|\?|\^\^
      scope: keyword.operator.logical.evi
    - match: \&|\^|\|
      scope: keyword.operator.bitwise.evi
    - match: --
      scope: keyword.operator.decrement.evi
    - match: \+\+
      scope: keyword.operator.increment.evi
    - match: \*|/|-|\+
      scope: keyword.operator.arithmetic.evi

  # EXPRESSION

  expression:
    - include: comment, pre-directive

    - include: call
    - include: operator
    - include: number
    - include: variable
    - include: string-char

    - include: punctuation
    - match: ';'
      scope: punctuation.terminator.expression.evi
      pop: true
    - include: invalids

  variable:
    - match: '(\$)({{ident}})'
      scope: meta.variable.evi
    - match: '(\$)([0-9]+)'
      scope: variable.parameter.evi

  call:
    - match: '({{ident}})\s*\('
      captures:
        1: variable.function.evi
      # push:
      #   - include: comment
      #   # args
      #   - meta_scope: meta.function-call-arguments.evi
      #   - include: expression
      #   - match: '\)'
      #     pop: true

  # STATEMENTS

  statement:
    - include: comment

    - include: assignment
    - include: return
    - include: if_and_loop
    - include: expression

  assignment:
    - include: comment
    - match: '(=)({{ident}})'
      captures:
        1: keyword.operator.assignment.evi
        2: meta.assignment.target.evi
      # push: expression

  return:
    - include: comment
    - match: \~
      scope: keyword.control.flow.return.evi
      set: expression

  if_and_loop:
    - include: comment
    - match: \?\?
      scope: keyword.control.flow.if.evi
    - match: '::'
      scope: keyword.control.flow.else.evi
    - match: \!\!
      scope: keyword.control.flow.loop.evi

  declaration:
    - include: comment, pre-directive

    # variable
    - match: '(\%)\s*({{ident}})(?:\s*\,\s*({{ident}}))*'
      captures:
        1: keyword.declaration.variable.evi,
        2: entity.name.variable.evi
        3: entity.name.variable.evi
        # 2: meta.declaration.variable.evi
        # 3: meta.declaration.variable.evi
      set:
        - include: comment
        - match: '{{type}}'
          scope: storage.type.evi
          set:
            - include: comment
            - meta_scope: meta.declaration.variable.initializer.evi
            - include: expression

            - match: ';'
              scope: punctuation.terminator.evi
              pop: true
          

        - match: \S
          scope: invalid.illegal.evi

    # functions
    - match: '(\@)\s*({{ident}})'
      captures:
        1: keyword.declaration.function.evi
        2: entity.name.function.evi
      push:
        - include: comment
        - match: \s*({{type}})?\s*\(
          captures:
            1: storage.type.returntype.evi
          push:
            - include: comment
            - meta_scope: meta.parameter_list.evi
            - include: comment, pre-directive

            - match: '\b{{type}}\b|\*'
              scope: variable.parameter.evi
            - match: \)
              pop: true
            - match: \S
              scope: invalid.illegal.evi
          pop: true
    
    - match: ';'
      scope: punctuation.terminator.evi

  # MISC

  punctuation:
    - match: '\,|\(|\)|\{|\}'
      scope: punctuation.separator.evi

  invalids:
    # - match: '\$|%|=|@|{{ident}}|{{number}}|{{type}}'
    - match: \S
      scope: invalid.misplaced.evi

  comment:
    - match: '\\:'
      scope: punctuation.definition.comment.evi
      push:
        - meta_scope: comment.block.evi
        - match: ':\\'
          pop: true

    - match: '\\\?'
      scope: punctuation.definition.comment.documentation.evi
      push:
        # This is an anonymous context push for brevity.
        - meta_scope: comment.line.documentation.evi
        - match: $\n?
          pop: true

    - match: '\\'
      scope: punctuation.definition.comment.evi
      push:
        # This is an anonymous context push for brevity.
        - meta_scope: comment.line.evi
        - match: $\n?
          pop: true

  escaped-char:
    # - match: \\(?:\\|[abefnrtv\'"?]|[0-3][0-9]{0,2}|[4-7][0-9]?|x[a-fA-F0-9]+|u[a-fA-F0-9]{4}|U[a-fA-F0-9]{8})
    - match: \\(?:a|b|e|f|n|r|t|v|\\|\'|\")
      scope: constant.character.escape.c
    - match: \\.
      scope: invalid.illegal.unknown-escape.c

  format-specifier:
      - match: |-
          (?x)%
            (\d+\$)?                                      # field (argument #)
            [#0\- +']*                                    # flags
            [,;:_]?                                       # separator character (AltiVec)
            ((-?\d+)|\*(-?\d+\$)?)?                       # minimum field width
            (\.((-?\d+)|\*(-?\d+\$)?)?)?                  # precision
            (hh|h|ll|l|j|t|z|q|L|vh|vl|v|hv|hl)?          # length modifier
            (\[[^\]]+\]|[am]s|[diouxXDOUeEfFgGaACcSspn%]) # conversion type
        scope: constant.other.placeholder.evi

  pre-directive:
    - match: ^\s*#apply
      scope: keyword.preprocessor.apply.evi
      push:
        - include: string-char
        - match: $\n?
          pop: true
        - include: invalids

    - match: ^\s*#(flag|unflag)
      scope: keyword.preprocessor.flag.evi
      push:
        - match: '[A-Za-z_]+[A-Za-z_0-9]*'
          scope: entity.name.constant.preprocessor.evi
        - match: $\n?
          pop: true
        - include: invalids

    - match: ^\s*#(line)
      scope: keyword.preprocessor.line.evi
      push:
        - match: '[0-9]+'
          scope: constant.numeric.decimal.evi
        - match: $\n?
          pop: true
        - include: invalids

    - match: ^\s*#(file)
      scope: keyword.preprocessor.file.evi
      push:
        - match: '\".*\"'
          scope: string.quoted.double.evi
        - match: $\n?
          pop: true
        - include: invalids

    - match: ^\s*#(ifset|ifnset)
      scope: keyword.preprocessor.conditional.evi
      push:
        - match: '[A-Za-z_]+[A-Za-z_0-9]*'
          scope: entity.name.constant.preprocessor.evi
        - match: $\n?
          pop: true
        - include: invalids

    - match: ^\s*#(else|endif)
      scope: keyword.preprocessor.conditional.evi
      push:
        - match: $\n?
          pop: true
        - include: invalids

    - match: ^\s*#(info)
      scope: keyword.preprocessor.pragma.evi
      push:
        - include: string-char
        - match: '[A-Za-z_0-9]+'
          scope: meta.preprocessor.pragma.args.evi
        - match: $\n?
          pop: true
        - include: invalids